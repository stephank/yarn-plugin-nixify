# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

{ lib, stdenv, nodejs, git, cacert, fetchurl, writeShellScript, writeShellScriptBin }:
{ src, overrideAttrs ? null, ... } @ args:

let

  yarnBin = @@YARN_BIN@@;

  cacheFolder = @@CACHE_FOLDER@@;
  lockfile = @@LOCKFILE@@;

  # Call overrideAttrs on a derivation if a function is provided.
  optionalOverride = fn: drv:
    if fn == null then drv else drv.overrideAttrs fn;

  # Simple stub that provides the global yarn command.
  yarn = writeShellScriptBin "yarn" ''
    exec ${lib.escapeShellArg "${nodejs}/bin/node"} ${lib.escapeShellArg yarnBin} "$@"
  '';

  # Common attributes between Yarn derivations.
  drvCommon = {
    # Make sure the build uses the right Node.js version everywhere.
    buildInputs = [ nodejs yarn ];
    # All dependencies should already be cached.
    yarn_enable_network = "0";
    # Tell node-gyp to use the provided Node.js headers for native code builds.
    npm_config_nodedir = nodejs;
  };

  # Comman variables that we set in a Nix build, but not in a Nix shell.
  buildVars = ''
    # Make Yarn produce friendlier logging for automated builds.
    export CI=1
    # Tell node-pre-gyp to never fetch binaries / always build from source.
    export npm_config_build_from_source=true
    # Disable Nixify plugin to save on some unnecessary processing.
    export yarn_enable_nixify=false
  '';

#@@ IF COMBINED_DRV
  cacheDrv = stdenv.mkDerivation {
    name = "yarn-cache";
    buildInputs = [ yarn git cacert ];
    buildCommand = ''
      cp --reflink=auto --recursive ${lib.escapeShellArg src} ./src
      cd ./src/
      ${buildVars}
      HOME="$TMP" yarn_enable_global_cache=false yarn_cache_folder="$out" \
        yarn nixify fetch
      rm $out/.gitignore
    '';
    outputHashMode = "recursive";
    outputHash = "@@COMBINED_HASH@@";
  };
#@@ ENDIF COMBINED_DRV
#@@ IF INDIVIDUAL_DRVS
  # Create derivations for fetching dependencies.
  cacheDrvs = let
  in lib.mapAttrs (locator: { filename, hash }: stdenv.mkDerivation {
    name = lib.strings.sanitizeDerivationName locator;
    buildInputs = [ yarn git cacert ];
    buildCommand = ''
      cd ${lib.escapeShellArg src}
      ${buildVars}
      HOME="$TMP" yarn_enable_global_cache=false yarn_cache_folder="$TMP" \
        yarn nixify fetch ${lib.escapeShellArg locator}
      # Because we change the cache dir, Yarn may generate a different name.
      mv "$TMP/$(sed 's/-[^-]*\.[^-]*$//' <<< "$outputFilename")"-* $out
    '';
    outputFilename = filename;
    outputHash = hash;
  }) cacheEntries;

  # Create a shell snippet to copy dependencies from a list of derivations.
  mkCacheBuilderForDrvs = drvs:
    writeShellScript "collect-yarn-cache" (lib.concatMapStrings (drv: ''
      cp --reflink=auto ${lib.escapeShellArg drv} ${lib.escapeShellArg drv.outputFilename}
    '') drvs);
#@@ ENDIF INDIVIDUAL_DRVS

#@@ IF NEED_ISOLATED_BUILD_SUPPRORT
#@@ IF INDIVIDUAL_DRVS
  # Create a shell snippet to copy dependencies from a list of locators.
  mkCacheBuilderForLocators = let
    pickCacheDrvs = map (locator: cacheDrvs.${locator});
  in locators:
    mkCacheBuilderForDrvs (pickCacheDrvs locators);
#@@ ENDIF INDIVIDUAL_DRVS

  # Create a derivation that builds a module in isolation.
  mkIsolatedBuild = { pname, version, reference, locators ? [] }: stdenv.mkDerivation (drvCommon // {
    inherit pname version;
    dontUnpack = true;

    configurePhase = ''
      ${buildVars}
      unset yarn_enable_nixify # plugin is not present
    '';

    buildPhase = ''
      mkdir -p .yarn/cache
#@@ IF COMBINED_DRV
      cp --reflink=auto --recursive ${lib.escapeShellArg cacheDrv}/* .yarn/cache/
#@@ ENDIF COMBINED_DRV
#@@ IF INDIVIDUAL_DRVS
      pushd .yarn/cache > /dev/null
      source ${lib.escapeShellArg (mkCacheBuilderForLocators locators)}
      popd > /dev/null
#@@ ENDIF INDIVIDUAL_DRVS

      echo ${lib.escapeShellArg (builtins.toJSON { dependencies.${pname} = reference; })} > package.json
      install -m 0600 ${lib.escapeShellArg lockfile} ./yarn.lock
      export yarn_global_folder="$TMP"
      export yarn_enable_global_cache=false
      export yarn_enable_immutable_installs=false
      yarn
    '';

    installPhase = ''
      unplugged=( .yarn/unplugged/${lib.escapeShellArg pname}-*/node_modules/* )
      if [[ ! -e "''${unplugged[@]}" ]]; then
        printf -- >&2 'Could not find the unplugged path for %s\n' ${lib.escapeShellArg pname}
        exit 1
      fi

      mv "$unplugged" $out
    '';
  });
#@@ ENDIF NEED_ISOLATED_BUILD_SUPPRORT

  # Main project derivation.
  project = stdenv.mkDerivation (drvCommon // {
    inherit src;
    name = @@PROJECT_NAME@@;

    configurePhase = ''
      ${buildVars}

      # Copy over the Yarn cache.
      rm -fr ${lib.escapeShellArg cacheFolder}
      mkdir -p ${lib.escapeShellArg cacheFolder}
#@@ IF COMBINED_DRV
      cp --reflink=auto --recursive ${lib.escapeShellArg cacheDrv}/* ${lib.escapeShellArg cacheFolder}/
#@@ ENDIF COMBINED_DRV
#@@ IF INDIVIDUAL_DRVS
      pushd ${lib.escapeShellArg cacheFolder} > /dev/null
      source ${lib.escapeShellArg (mkCacheBuilderForDrvs (lib.attrValues cacheDrvs))}
      popd > /dev/null
#@@ ENDIF INDIVIDUAL_DRVS

      # Yarn may need a writable home directory.
      export yarn_global_folder="$TMP"

      # Ensure global cache is disabled. Cache must be part of our output.
      touch .yarnrc.yml
      sed -i -e '/^enableGlobalCache/d' .yarnrc.yml
      echo 'enableGlobalCache: false' >> .yarnrc.yml

      # Some node-gyp calls may call out to npm, which could fail due to an
      # read-only home dir.
      export HOME="$TMP"

      # running preConfigure after the cache is populated allows for
      # preConfigure to contain substituteInPlace for dependencies as well as the
      # main project. This is necessary for native bindings that maybe have
      # hardcoded values.
      runHook preConfigure

@@ISOLATED_INTEGRATION@@

      # Run normal Yarn install to complete dependency installation.
      yarn install --immutable --immutable-cache

      runHook postConfigure
    '';

    buildPhase = ''
      runHook preBuild
      runHook postBuild
    '';

    installPhase = ''
      runHook preInstall

      # Move the package contents to the output directory.
      if grep -q '"workspaces"' package.json; then
        # We can't use `yarn pack` in a workspace setup, because it only
        # packages the outer workspace.
        mkdir -p "$out/libexec"
        mv $PWD "$out/libexec/$name"
      else
        # - If the package.json has a `files` field, only files matching those patterns are copied
        # - Otherwise all files are copied.
        yarn pack --out package.tgz
        mkdir -p "$out/libexec/$name"
        tar xzf package.tgz --directory "$out/libexec/$name" --strip-components=1

        cp --reflink=auto .yarnrc* "$out/libexec/$name"
        cp --reflink=auto ${lib.escapeShellArg lockfile} "$out/libexec/$name/yarn.lock"
        cp --reflink=auto --recursive .yarn "$out/libexec/$name"

        # Copy the Yarn linker output into the package.
#@@ IF USES_PNP_LINKER
        cp --reflink=auto .pnp.* "$out/libexec/$name"
#@@ ENDIF USES_PNP_LINKER
#@@ IF USES_NM_LINKER
        cp --reflink=auto --recursive node_modules "$out/libexec/$name"
#@@ ENDIF USES_NM_LINKER
      fi

      cd "$out/libexec/$name"

      # Invoke a plugin internal command to setup binaries.
      mkdir -p "$out/bin"
      yarn nixify install-bin $out/bin

#@@ IF USES_NM_LINKER
      # A package with node_modules doesn't need the cache
      yarn cache clean
#@@ ENDIF USES_NM_LINKER

      runHook postInstall
    '';

    passthru = {
      inherit nodejs;
      yarn-freestanding = yarn;
      yarn = writeShellScriptBin "yarn" ''
        exec ${lib.escapeShellArg "${yarn}/bin/yarn"} \
          --cwd ${lib.escapeShellArg "${overriddenProject}/libexec/${overriddenProject.name}"} \
          "$@"
      '';
    };
  });

  overriddenProject = optionalOverride overrideAttrs project;

@@CACHE_ENTRIES@@
@@ISOLATED@@
in overriddenProject
